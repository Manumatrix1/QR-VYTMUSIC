<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sistema de Pruebas VYT - Testing Completo</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #111827; color: #f9fafb; }
        .hidden { display: none !important; }
        .test-step {
            transition: all 0.3s ease;
            border-left: 4px solid #3b82f6;
        }
        .test-step.completed {
            border-left-color: #10b981;
            background-color: rgba(16, 185, 129, 0.1);
        }
        .test-step.failed {
            border-left-color: #ef4444;
            background-color: rgba(239, 68, 68, 0.1);
        }
        .test-step.current {
            border-left-color: #f59e0b;
            background-color: rgba(245, 158, 11, 0.1);
            transform: scale(1.02);
        }
        .progress-bar {
            transition: width 0.5s ease;
        }
    </style>
</head>
<body>
    <div class="container mx-auto max-w-6xl p-4 sm:p-6">
        <header class="text-center mb-8">
            <a id="back-to-panel-link" href="#" class="text-sky-400 hover:underline mb-4 inline-block">&larr; Volver al Panel</a>
            <h1 class="text-4xl sm:text-5xl font-bold text-sky-400">üß™ Sistema de Pruebas VYT</h1>
            <p id="event-name-display" class="text-2xl text-gray-300 mt-2"></p>
            <p class="text-gray-400 mt-2">Testing completo y aut√©ntico del sistema antes de la gala</p>
        </header>

        <!-- Panel de Control de Pruebas -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-8">
            <div class="bg-gray-800 p-6 rounded-lg shadow-xl">
                <h2 class="text-xl font-bold mb-4 text-green-400">üéØ Control de Pruebas</h2>
                <div class="space-y-3">
                    <button id="start-full-test-btn" class="w-full px-4 py-3 bg-green-600 text-white font-bold rounded-lg hover:bg-green-700">
                        üöÄ Iniciar Prueba Completa
                    </button>
                    <button id="reset-test-btn" class="w-full px-4 py-2 bg-red-600 text-white font-bold rounded-lg hover:bg-red-700">
                        üîÑ Reiniciar Pruebas
                    </button>
                    <button id="create-test-data-btn" class="w-full px-4 py-2 bg-blue-600 text-white font-bold rounded-lg hover:bg-blue-700">
                        üì¶ Crear Datos de Prueba
                    </button>
                </div>
            </div>

            <div class="bg-gray-800 p-6 rounded-lg shadow-xl">
                <h2 class="text-xl font-bold mb-4 text-yellow-400">üìä Progreso General</h2>
                <div class="mb-4">
                    <div class="flex justify-between text-sm mb-2">
                        <span>Progreso</span>
                        <span id="progress-percentage">0%</span>
                    </div>
                    <div class="w-full bg-gray-700 rounded-full h-3">
                        <div id="progress-bar" class="progress-bar bg-yellow-400 h-3 rounded-full" style="width: 0%"></div>
                    </div>
                </div>
                <div class="grid grid-cols-3 gap-2 text-center text-sm">
                    <div>
                        <div class="text-lg font-bold text-green-400" id="tests-passed">0</div>
                        <div class="text-gray-400">Pasaron</div>
                    </div>
                    <div>
                        <div class="text-lg font-bold text-red-400" id="tests-failed">0</div>
                        <div class="text-gray-400">Fallaron</div>
                    </div>
                    <div>
                        <div class="text-lg font-bold text-gray-400" id="tests-total">12</div>
                        <div class="text-gray-400">Total</div>
                    </div>
                </div>
            </div>

            <div class="bg-gray-800 p-6 rounded-lg shadow-xl">
                <h2 class="text-xl font-bold mb-4 text-purple-400">‚ö° Acciones R√°pidas</h2>
                <div class="space-y-2">
                    <button id="test-scanner-btn" class="w-full px-3 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700">
                        üì∑ Test Esc√°ner
                    </button>
                    <button id="test-voting-btn" class="w-full px-3 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700">
                        üó≥Ô∏è Test Votaci√≥n
                    </button>
                    <button id="test-reports-btn" class="w-full px-3 py-2 bg-teal-600 text-white rounded-lg hover:bg-teal-700">
                        üìä Test Reportes
                    </button>
                </div>
            </div>
        </div>

        <!-- Lista de Pruebas -->
        <div class="bg-gray-800 p-6 rounded-lg shadow-xl">
            <h2 class="text-2xl font-bold mb-6 text-center">üß™ Bater√≠a de Pruebas del Sistema</h2>
            
            <div id="test-steps" class="space-y-4">
                <!-- Las pruebas se generar√°n din√°micamente -->
            </div>
        </div>

        <!-- Resultados Detallados -->
        <div id="test-results" class="bg-gray-800 p-6 rounded-lg shadow-xl mt-6 hidden">
            <h2 class="text-2xl font-bold mb-4 text-green-400">‚úÖ Resultados de las Pruebas</h2>
            <div id="results-content" class="space-y-4"></div>
            
            <div class="mt-6 p-4 bg-green-900 bg-opacity-50 rounded-lg">
                <h3 class="text-lg font-bold text-green-300 mb-2">üé™ Estado para la Gala:</h3>
                <p id="gala-readiness" class="text-green-200"></p>
            </div>
        </div>

        <!-- Log de Actividades -->
        <div class="bg-gray-800 p-6 rounded-lg shadow-xl mt-6">
            <h2 class="text-xl font-bold mb-4 text-gray-300">üìù Log de Actividades</h2>
            <div id="activity-log" class="bg-gray-900 p-4 rounded-lg max-h-64 overflow-y-auto font-mono text-sm">
                <p class="text-gray-400">Sistema de pruebas inicializado. Presiona "Iniciar Prueba Completa" para comenzar.</p>
            </div>
        </div>
    </div>

    <script type="module">
        import { db, auth } from './firebase_config.js';
        import { collection, doc, getDocs, addDoc, updateDoc, deleteDoc, query, where, orderBy } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";

        class VYTTestingSystem {
            constructor() {
                this.eventId = null;
                this.eventName = null;
                this.testResults = [];
                this.currentTestIndex = 0;
                this.testsPassed = 0;
                this.testsFailed = 0;
                
                this.initializeFromURL();
                this.setupEventListeners();
                this.initializeTestSteps();
            }

            initializeFromURL() {
                const urlParams = new URLSearchParams(window.location.search);
                this.eventId = urlParams.get('eventId');
                this.eventName = urlParams.get('eventName');

                if (!this.eventId || !this.eventName) {
                    alert('Error: No se ha especificado un evento para las pruebas.');
                    window.location.href = 'eventos.html';
                    return;
                }

                document.getElementById('back-to-panel-link').href = `panel_evento.html?eventId=${this.eventId}&eventName=${encodeURIComponent(this.eventName)}`;
                document.getElementById('event-name-display').textContent = `PRUEBAS: ${this.eventName}`;
            }

            initializeTestSteps() {
                const tests = [
                    {
                        id: 'firebase-connection',
                        title: 'üîó Conexi√≥n a Firebase',
                        description: 'Verificar conectividad y autenticaci√≥n'
                    },
                    {
                        id: 'event-data',
                        title: 'üìã Datos del Evento',
                        description: 'Validar informaci√≥n del evento y artistas'
                    },
                    {
                        id: 'ticket-generation',
                        title: 'üé´ Generaci√≥n de Entradas',
                        description: 'Crear entradas de prueba'
                    },
                    {
                        id: 'door-ticket-generation',
                        title: 'üö™ Generaci√≥n Entrada Puerta',
                        description: 'Crear entrada en puerta de prueba'
                    },
                    {
                        id: 'qr-scanning',
                        title: 'üì∑ Escaneo QR',
                        description: 'Validar funcionalidad del esc√°ner'
                    },
                    {
                        id: 'vote-enablement',
                        title: 'üó≥Ô∏è Habilitaci√≥n Votaci√≥n',
                        description: 'Verificar que se habilite votaci√≥n tras escaneo'
                    },
                    {
                        id: 'voting-process',
                        title: 'üéØ Proceso de Votaci√≥n',
                        description: 'Simular votaci√≥n completa'
                    },
                    {
                        id: 'vote-validation',
                        title: '‚úÖ Validaci√≥n de Votos',
                        description: 'Confirmar almacenamiento de votos'
                    },
                    {
                        id: 'reports-generation',
                        title: 'üìä Generaci√≥n de Reportes',
                        description: 'Verificar reportes en tiempo real'
                    },
                    {
                        id: 'offline-mode',
                        title: 'üì° Modo Offline',
                        description: 'Probar funcionalidad sin conexi√≥n'
                    },
                    {
                        id: 'data-export',
                        title: 'üíæ Exportaci√≥n de Datos',
                        description: 'Validar exportaci√≥n a Excel/CSV'
                    },
                    {
                        id: 'system-performance',
                        title: '‚ö° Rendimiento del Sistema',
                        description: 'Medir tiempos de respuesta'
                    }
                ];

                const container = document.getElementById('test-steps');
                container.innerHTML = tests.map((test, index) => `
                    <div id="test-${test.id}" class="test-step bg-gray-700 p-4 rounded-lg">
                        <div class="flex items-center justify-between">
                            <div class="flex items-center space-x-3">
                                <div class="flex-shrink-0">
                                    <div class="w-8 h-8 rounded-full bg-gray-600 flex items-center justify-center text-sm font-bold">
                                        ${index + 1}
                                    </div>
                                </div>
                                <div>
                                    <h3 class="font-semibold">${test.title}</h3>
                                    <p class="text-sm text-gray-400">${test.description}</p>
                                </div>
                            </div>
                            <div id="status-${test.id}" class="flex-shrink-0">
                                <span class="text-gray-400">‚è≥ Pendiente</span>
                            </div>
                        </div>
                        <div id="details-${test.id}" class="mt-3 text-sm text-gray-300 hidden">
                            <!-- Detalles del test se mostrar√°n aqu√≠ -->
                        </div>
                    </div>
                `).join('');
            }

            async runFullTest() {
                this.log('üöÄ Iniciando prueba completa del sistema...');
                this.resetTestResults();

                const tests = [
                    () => this.testFirebaseConnection(),
                    () => this.testEventData(),
                    () => this.testTicketGeneration(),
                    () => this.testDoorTicketGeneration(),
                    () => this.testQRScanning(),
                    () => this.testVoteEnablement(),
                    () => this.testVotingProcess(),
                    () => this.testVoteValidation(),
                    () => this.testReportsGeneration(),
                    () => this.testOfflineMode(),
                    () => this.testDataExport(),
                    () => this.testSystemPerformance()
                ];

                for (let i = 0; i < tests.length; i++) {
                    this.currentTestIndex = i;
                    this.updateCurrentTest(i);
                    
                    try {
                        const result = await tests[i]();
                        this.updateTestResult(i, true, result.message, result.details);
                        this.testsPassed++;
                    } catch (error) {
                        this.updateTestResult(i, false, error.message, error.details);
                        this.testsFailed++;
                    }

                    this.updateProgress();
                    await new Promise(resolve => setTimeout(resolve, 500)); // Pausa entre tests
                }

                this.showFinalResults();
            }

            async testFirebaseConnection() {
                this.log('üîó Probando conexi√≥n a Firebase...');
                
                try {
                    // Probar lectura
                    const testCollection = collection(db, `events/${this.eventId}/tickets`);
                    await getDocs(testCollection);
                    
                    // Probar escritura
                    const testDoc = await addDoc(collection(db, `events/${this.eventId}/test_logs`), {
                        test: 'connection',
                        timestamp: new Date().toISOString(),
                        status: 'success'
                    });

                    // Limpiar
                    await deleteDoc(testDoc);

                    return {
                        message: '‚úÖ Conexi√≥n a Firebase exitosa',
                        details: 'Lectura y escritura funcionando correctamente'
                    };
                } catch (error) {
                    throw {
                        message: '‚ùå Error de conexi√≥n a Firebase',
                        details: error.message
                    };
                }
            }

            async testEventData() {
                this.log('üìã Validando datos del evento...');
                
                try {
                    // Verificar artistas
                    const artistsQuery = collection(db, `events/${this.eventId}/artists`);
                    const artistsSnapshot = await getDocs(artistsQuery);
                    const artistsCount = artistsSnapshot.size;

                    // Verificar tickets existentes
                    const ticketsQuery = collection(db, `events/${this.eventId}/tickets`);
                    const ticketsSnapshot = await getDocs(ticketsQuery);
                    const ticketsCount = ticketsSnapshot.size;

                    if (artistsCount === 0) {
                        throw {
                            message: '‚ö†Ô∏è No hay artistas registrados',
                            details: 'Necesitas agregar artistas antes de las pruebas'
                        };
                    }

                    return {
                        message: `‚úÖ Datos del evento validados`,
                        details: `${artistsCount} artistas, ${ticketsCount} entradas existentes`
                    };
                } catch (error) {
                    throw {
                        message: '‚ùå Error validando datos del evento',
                        details: error.message || error.details
                    };
                }
            }

            async testTicketGeneration() {
                this.log('üé´ Probando generaci√≥n de entradas...');
                
                try {
                    const testTicket = {
                        id: `TEST-${Date.now()}`,
                        prefix: 'TEST',
                        name: 'Usuario de Prueba',
                        showName: this.eventName,
                        paymentStatus: 'Paga',
                        used: false,
                        canVote: false,
                        generatedAt: new Date().toISOString()
                    };

                    await addDoc(collection(db, `events/${this.eventId}/tickets`), testTicket);

                    return {
                        message: '‚úÖ Generaci√≥n de entradas funcionando',
                        details: `Entrada de prueba creada: ${testTicket.id}`
                    };
                } catch (error) {
                    throw {
                        message: '‚ùå Error generando entrada',
                        details: error.message
                    };
                }
            }

            async testDoorTicketGeneration() {
                this.log('üö™ Probando generaci√≥n entrada en puerta...');
                
                try {
                    const doorTicket = {
                        id: `PUERTA-TEST-${Date.now()}`,
                        prefix: 'PUERTA',
                        name: 'Cliente Puerta Prueba',
                        showName: this.eventName,
                        paymentStatus: 'cobrada',
                        used: false,
                        isDoorSale: true,
                        soldBy: 'Sistema de Pruebas',
                        canVote: true,
                        voteEligible: true,
                        entryAuthorized: true,
                        generatedAt: new Date().toISOString()
                    };

                    await addDoc(collection(db, `events/${this.eventId}/tickets`), doorTicket);

                    return {
                        message: '‚úÖ Generaci√≥n entrada puerta funcionando',
                        details: `Entrada puerta creada con habilitaci√≥n de voto: ${doorTicket.id}`
                    };
                } catch (error) {
                    throw {
                        message: '‚ùå Error generando entrada puerta',
                        details: error.message
                    };
                }
            }

            async testQRScanning() {
                this.log('üì∑ Simulando escaneo QR...');
                
                try {
                    // Buscar una entrada de prueba para escanear
                    const ticketsQuery = query(
                        collection(db, `events/${this.eventId}/tickets`),
                        where('prefix', '==', 'TEST')
                    );
                    const snapshot = await getDocs(ticketsQuery);
                    
                    if (snapshot.empty) {
                        throw {
                            message: '‚ùå No hay entradas de prueba para escanear',
                            details: 'Se necesitan entradas de prueba creadas previamente'
                        };
                    }

                    // Simular escaneo (marcar como usada)
                    const testTicket = snapshot.docs[0];
                    await updateDoc(testTicket.ref, {
                        used: true,
                        usedAt: new Date().toISOString(),
                        usedBy: 'Sistema de Pruebas',
                        canVote: true,
                        voteEligible: true,
                        entryAuthorized: true
                    });

                    return {
                        message: '‚úÖ Escaneo QR simulado exitosamente',
                        details: 'Entrada marcada como usada y habilitada para votar'
                    };
                } catch (error) {
                    throw {
                        message: '‚ùå Error en simulaci√≥n de escaneo',
                        details: error.message || error.details
                    };
                }
            }

            async testVoteEnablement() {
                this.log('üó≥Ô∏è Verificando habilitaci√≥n de votaci√≥n...');
                
                try {
                    // Buscar entradas que deber√≠an poder votar
                    const enabledQuery = query(
                        collection(db, `events/${this.eventId}/tickets`),
                        where('canVote', '==', true)
                    );
                    const enabledSnapshot = await getDocs(enabledQuery);
                    
                    if (enabledSnapshot.empty) {
                        throw {
                            message: '‚ùå No hay entradas habilitadas para votar',
                            details: 'Las entradas escaneadas deben tener canVote: true'
                        };
                    }

                    return {
                        message: '‚úÖ Habilitaci√≥n de votaci√≥n funcionando',
                        details: `${enabledSnapshot.size} entradas habilitadas para votar`
                    };
                } catch (error) {
                    throw {
                        message: '‚ùå Error verificando habilitaci√≥n',
                        details: error.message || error.details
                    };
                }
            }

            async testVotingProcess() {
                this.log('üéØ Simulando proceso de votaci√≥n...');
                
                try {
                    // Obtener artistas para votar
                    const artistsSnapshot = await getDocs(collection(db, `events/${this.eventId}/artists`));
                    if (artistsSnapshot.empty) {
                        throw {
                            message: '‚ùå No hay artistas para votar',
                            details: 'Se necesitan artistas registrados para probar votaci√≥n'
                        };
                    }

                    // Obtener entrada de prueba habilitada
                    const ticketQuery = query(
                        collection(db, `events/${this.eventId}/tickets`),
                        where('canVote', '==', true)
                    );
                    const ticketSnapshot = await getDocs(ticketQuery);
                    
                    if (ticketSnapshot.empty) {
                        throw {
                            message: '‚ùå No hay entradas habilitadas',
                            details: 'Se necesita al menos una entrada con canVote: true'
                        };
                    }

                    const testTicket = ticketSnapshot.docs[0];
                    const firstArtist = artistsSnapshot.docs[0];

                    // Simular voto
                    const voteData = {
                        singingScore: 8,
                        transmissionScore: 7,
                        attitudeScore: 9,
                        originalityScore: 8,
                        costumeScore: 7,
                        stagingScore: 8,
                        timestamp: new Date().toISOString(),
                        testVote: true
                    };

                    await addDoc(
                        collection(db, `events/${this.eventId}/ticket_votes/${testTicket.id}/votes`),
                        { [firstArtist.id]: voteData }
                    );

                    return {
                        message: '‚úÖ Proceso de votaci√≥n funcionando',
                        details: `Voto de prueba registrado para ${firstArtist.data().name}`
                    };
                } catch (error) {
                    throw {
                        message: '‚ùå Error en proceso de votaci√≥n',
                        details: error.message || error.details
                    };
                }
            }

            async testVoteValidation() {
                this.log('‚úÖ Validando almacenamiento de votos...');
                
                try {
                    // Buscar votos de prueba
                    const ticketQuery = query(
                        collection(db, `events/${this.eventId}/tickets`),
                        where('canVote', '==', true)
                    );
                    const ticketSnapshot = await getDocs(ticketQuery);
                    
                    if (!ticketSnapshot.empty) {
                        const testTicket = ticketSnapshot.docs[0];
                        const votesSnapshot = await getDocs(
                            collection(db, `events/${this.eventId}/ticket_votes/${testTicket.id}/votes`)
                        );

                        if (votesSnapshot.empty) {
                            throw {
                                message: '‚ùå No se encontraron votos registrados',
                                details: 'Los votos no se est√°n almacenando correctamente'
                            };
                        }

                        return {
                            message: '‚úÖ Validaci√≥n de votos exitosa',
                            details: `${votesSnapshot.size} votos encontrados y validados`
                        };
                    }

                    throw {
                        message: '‚ùå No hay entradas para validar votos',
                        details: 'Se necesitan entradas con votos para validar'
                    };
                } catch (error) {
                    throw {
                        message: '‚ùå Error validando votos',
                        details: error.message || error.details
                    };
                }
            }

            async testReportsGeneration() {
                this.log('üìä Probando generaci√≥n de reportes...');
                
                try {
                    // Simular acceso a reportes
                    const artistsSnapshot = await getDocs(collection(db, `events/${this.eventId}/artists`));
                    const ticketsSnapshot = await getDocs(collection(db, `events/${this.eventId}/tickets`));
                    
                    const reportData = {
                        totalArtistas: artistsSnapshot.size,
                        totalEntradas: ticketsSnapshot.size,
                        entradasUsadas: 0,
                        entradasHabilitadas: 0
                    };

                    ticketsSnapshot.forEach(doc => {
                        const data = doc.data();
                        if (data.used) reportData.entradasUsadas++;
                        if (data.canVote) reportData.entradasHabilitadas++;
                    });

                    return {
                        message: '‚úÖ Generaci√≥n de reportes funcionando',
                        details: `Datos: ${reportData.totalArtistas} artistas, ${reportData.entradasUsadas}/${reportData.totalEntradas} entradas usadas`
                    };
                } catch (error) {
                    throw {
                        message: '‚ùå Error generando reportes',
                        details: error.message
                    };
                }
            }

            async testOfflineMode() {
                this.log('üì° Probando modo offline...');
                
                try {
                    // Simular almacenamiento local
                    const offlineData = {
                        eventId: this.eventId,
                        timestamp: new Date().toISOString(),
                        syncQueue: [
                            {
                                type: 'scan',
                                ticketId: 'TEST-OFFLINE',
                                timestamp: new Date().toISOString()
                            }
                        ]
                    };

                    localStorage.setItem(`vyt_test_offline_${this.eventId}`, JSON.stringify(offlineData));
                    
                    // Verificar almacenamiento
                    const stored = localStorage.getItem(`vyt_test_offline_${this.eventId}`);
                    if (!stored) {
                        throw {
                            message: '‚ùå Almacenamiento local no funciona',
                            details: 'No se puede guardar datos en localStorage'
                        };
                    }

                    // Limpiar
                    localStorage.removeItem(`vyt_test_offline_${this.eventId}`);

                    return {
                        message: '‚úÖ Modo offline funcionando',
                        details: 'Almacenamiento local y cola de sincronizaci√≥n operativos'
                    };
                } catch (error) {
                    throw {
                        message: '‚ùå Error en modo offline',
                        details: error.message || error.details
                    };
                }
            }

            async testDataExport() {
                this.log('üíæ Probando exportaci√≥n de datos...');
                
                try {
                    // Simular generaci√≥n de CSV
                    const csvData = [
                        ['Ticket ID', 'Nombre', 'Estado', 'Timestamp'],
                        ['TEST-001', 'Usuario Prueba', 'Usado', new Date().toISOString()],
                        ['TEST-002', 'Usuario Prueba 2', 'Pendiente', new Date().toISOString()]
                    ];

                    const csvContent = csvData.map(row => row.join(',')).join('\\n');
                    
                    if (csvContent.length < 50) {
                        throw {
                            message: '‚ùå Error generando CSV',
                            details: 'Contenido CSV demasiado corto'
                        };
                    }

                    return {
                        message: '‚úÖ Exportaci√≥n de datos funcionando',
                        details: `CSV generado con ${csvData.length - 1} registros`
                    };
                } catch (error) {
                    throw {
                        message: '‚ùå Error exportando datos',
                        details: error.message || error.details
                    };
                }
            }

            async testSystemPerformance() {
                this.log('‚ö° Midiendo rendimiento del sistema...');
                
                try {
                    const startTime = performance.now();
                    
                    // Realizar operaciones t√≠picas
                    await getDocs(collection(db, `events/${this.eventId}/tickets`));
                    await getDocs(collection(db, `events/${this.eventId}/artists`));
                    
                    const endTime = performance.now();
                    const responseTime = endTime - startTime;

                    if (responseTime > 5000) {
                        throw {
                            message: '‚ö†Ô∏è Rendimiento lento detectado',
                            details: `Tiempo de respuesta: ${responseTime.toFixed(0)}ms (>5s)`
                        };
                    }

                    return {
                        message: '‚úÖ Rendimiento del sistema aceptable',
                        details: `Tiempo de respuesta: ${responseTime.toFixed(0)}ms`
                    };
                } catch (error) {
                    throw {
                        message: '‚ùå Error midiendo rendimiento',
                        details: error.message || error.details
                    };
                }
            }

            updateCurrentTest(index) {
                // Limpiar estado anterior
                document.querySelectorAll('.test-step').forEach(el => {
                    el.classList.remove('current');
                });

                // Marcar test actual
                const tests = document.querySelectorAll('.test-step');
                if (tests[index]) {
                    tests[index].classList.add('current');
                    tests[index].scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }

            updateTestResult(index, passed, message, details) {
                const tests = document.querySelectorAll('.test-step');
                const statusEl = document.getElementById(`status-${tests[index].id.replace('test-', '')}`);
                const detailsEl = document.getElementById(`details-${tests[index].id.replace('test-', '')}`);

                tests[index].classList.remove('current');
                tests[index].classList.add(passed ? 'completed' : 'failed');
                
                statusEl.innerHTML = passed ? 
                    '<span class="text-green-400">‚úÖ Pas√≥</span>' : 
                    '<span class="text-red-400">‚ùå Fall√≥</span>';

                if (details) {
                    detailsEl.innerHTML = `<strong>${message}</strong><br><span class="text-gray-400">${details}</span>`;
                    detailsEl.classList.remove('hidden');
                }

                this.log(`${passed ? '‚úÖ' : '‚ùå'} ${message}`);
            }

            updateProgress() {
                const total = 12;
                const completed = this.testsPassed + this.testsFailed;
                const percentage = Math.round((completed / total) * 100);

                document.getElementById('progress-bar').style.width = `${percentage}%`;
                document.getElementById('progress-percentage').textContent = `${percentage}%`;
                document.getElementById('tests-passed').textContent = this.testsPassed;
                document.getElementById('tests-failed').textContent = this.testsFailed;
            }

            showFinalResults() {
                const total = this.testsPassed + this.testsFailed;
                const successRate = Math.round((this.testsPassed / total) * 100);

                let readinessMessage;
                if (successRate >= 95) {
                    readinessMessage = 'üéâ SISTEMA COMPLETAMENTE LISTO PARA LA GALA - Todos los componentes cr√≠ticos funcionando perfectamente.';
                } else if (successRate >= 85) {
                    readinessMessage = '‚úÖ SISTEMA LISTO CON OBSERVACIONES - Revisa los tests fallidos pero es seguro proceder.';
                } else if (successRate >= 70) {
                    readinessMessage = '‚ö†Ô∏è SISTEMA PARCIALMENTE LISTO - Se recomienda resolver los problemas antes de la gala.';
                } else {
                    readinessMessage = '‚ùå SISTEMA NO LISTO - Problemas cr√≠ticos detectados. NO proceder con la gala hasta resolver.';
                }

                document.getElementById('gala-readiness').textContent = readinessMessage;
                document.getElementById('test-results').classList.remove('hidden');
                document.getElementById('test-results').scrollIntoView({ behavior: 'smooth' });

                this.log(`üèÅ Pruebas completadas: ${this.testsPassed}/${total} exitosas (${successRate}%)`);
            }

            resetTestResults() {
                this.testsPassed = 0;
                this.testsFailed = 0;
                this.currentTestIndex = 0;
                
                document.querySelectorAll('.test-step').forEach(el => {
                    el.classList.remove('completed', 'failed', 'current');
                });

                document.querySelectorAll('[id^="status-"]').forEach(el => {
                    el.innerHTML = '<span class="text-gray-400">‚è≥ Pendiente</span>';
                });

                document.querySelectorAll('[id^="details-"]').forEach(el => {
                    el.classList.add('hidden');
                });

                document.getElementById('test-results').classList.add('hidden');
                this.updateProgress();
            }

            async createTestData() {
                this.log('üì¶ Creando datos de prueba...');
                
                try {
                    // Crear artista de prueba si no existe
                    const artistsSnapshot = await getDocs(collection(db, `events/${this.eventId}/artists`));
                    if (artistsSnapshot.empty) {
                        await addDoc(collection(db, `events/${this.eventId}/artists`), {
                            name: 'Artista de Prueba',
                            description: 'Artista creado para testing del sistema',
                            photoURL: 'https://placehold.co/300x300/1f2937/f9fafb?text=TEST',
                            isTestData: true,
                            createdAt: new Date().toISOString()
                        });
                        this.log('‚úÖ Artista de prueba creado');
                    }

                    // Crear entrada de prueba
                    const testTicket = {
                        id: `TEST-SETUP-${Date.now()}`,
                        prefix: 'TEST-SETUP',
                        name: 'Usuario Setup Prueba',
                        showName: this.eventName,
                        paymentStatus: 'Paga',
                        used: false,
                        canVote: false,
                        isTestData: true,
                        generatedAt: new Date().toISOString()
                    };

                    await addDoc(collection(db, `events/${this.eventId}/tickets`), testTicket);
                    this.log('‚úÖ Entrada de prueba creada');

                    alert('üì¶ Datos de prueba creados exitosamente');
                } catch (error) {
                    this.log(`‚ùå Error creando datos de prueba: ${error.message}`);
                    alert('‚ùå Error creando datos de prueba');
                }
            }

            log(message) {
                const logEl = document.getElementById('activity-log');
                const timestamp = new Date().toLocaleTimeString();
                logEl.innerHTML += `<br>[${timestamp}] ${message}`;
                logEl.scrollTop = logEl.scrollHeight;
            }

            setupEventListeners() {
                document.getElementById('start-full-test-btn').addEventListener('click', () => {
                    this.runFullTest();
                });

                document.getElementById('reset-test-btn').addEventListener('click', () => {
                    this.resetTestResults();
                    this.log('üîÑ Tests reiniciados');
                });

                document.getElementById('create-test-data-btn').addEventListener('click', () => {
                    this.createTestData();
                });

                document.getElementById('test-scanner-btn').addEventListener('click', () => {
                    window.open(`escaner_unificado.html?eventId=${this.eventId}&eventName=${encodeURIComponent(this.eventName)}`, '_blank');
                });

                document.getElementById('test-voting-btn').addEventListener('click', () => {
                    window.open(`voting_page.html?eventId=${this.eventId}`, '_blank');
                });

                document.getElementById('test-reports-btn').addEventListener('click', () => {
                    window.open(`reportes.html?eventId=${this.eventId}&eventName=${encodeURIComponent(this.eventName)}`, '_blank');
                });
            }
        }

        // Inicializar sistema de pruebas
        const testingSystem = new VYTTestingSystem();
    </script>
</body>
</html>